Perfect, GrÃ©goire â€” hereâ€™s a **complete, VPSâ€‘oriented, stepâ€‘byâ€‘step** guide for running **Strapi (backend) + PostgreSQL + Next.js (frontend)** behind **Caddy** (TLS + reverse proxy), all on a **Hetzner VPS**. It includes:

*   folder structure
*   Docker & Dockerfiles
*   Caddy config (+ automatic HTTPS)
*   environment variables (.env)
*   DNS records to create
*   backup scripts (DB + media)
*   deploy & update commands
*   small hardening checklist

Everything is **selfâ€‘hosted** and fits your **â‰¤ 10 CHF/month** target.

***

## 0) Prerequisites on the VPS

*   A fresh Ubuntu/Debian VPS (e.g., Hetzner CPX21/CX22 or similar)
*   Your `.ch` domain (e.g., `example.ch`)
*   DNS access at your registrar

### Install system packages & Docker

```bash
# Update & essentials
sudo apt-get update && sudo apt-get upgrade -y
sudo apt-get install -y ca-certificates curl git ufw

# Docker Engine + Compose plugin (official convenience script)
curl -fsSL https://get.docker.com | sudo sh
sudo usermod -aG docker $USER
newgrp docker

# Enable firewall (allow SSH, HTTP, HTTPS)
sudo ufw allow OpenSSH
sudo ufw allow 80,443/tcp
sudo ufw enable
sudo ufw status
```

***

## 1) Project layout

Weâ€™ll keep everything in a single repo on the VPS.

    people-events/
    â”œâ”€ infra/
    â”‚  â”œâ”€ docker-compose.yml
    â”‚  â”œâ”€ .env
    â”‚  â”œâ”€ Caddyfile
    â”‚  â”œâ”€ backup/
    â”‚  â”‚  â”œâ”€ backup.sh
    â”‚  â”‚  â””â”€ restore-notes.md
    â”œâ”€ backend/              # Strapi app
    â”‚  â”œâ”€ Dockerfile
    â”‚  â”œâ”€ .env
    â”‚  â”œâ”€ config/            # Strapi env-based configs
    â”‚  â”‚  â”œâ”€ database.ts
    â”‚  â”‚  â”œâ”€ server.ts
    â”‚  â”‚  â””â”€ plugins.ts
    â”‚  â””â”€ (Strapi files generated by create-strapi-app)
    â””â”€ frontend/             # Next.js app
       â”œâ”€ Dockerfile
       â”œâ”€ .env
       â””â”€ (Next.js files from create-next-app)

> If you already bootstrapped Strapi/Next.js locally, copy them into `backend/` and `frontend/`. Otherwise the guide includes the core configs you need.

***

## 2) DNS records to create

At your domain registrarâ€™s DNS panel:

    A    example.ch        -> <your VPS IPv4>
    AAAA example.ch        -> <your VPS IPv6>      # optional but recommended
    A    www.example.ch    -> <your VPS IPv4>      # optional (or redirect)
    AAAA www.example.ch    -> <your VPS IPv6>      # optional
    A    api.example.ch    -> <your VPS IPv4>
    AAAA api.example.ch    -> <your VPS IPv6>      # optional

*   Weâ€™ll serve **Next.js** at `https://example.ch`
*   Weâ€™ll serve **Strapi** at `https://api.example.ch`

After you point DNS, give it a few minutes to propagate.

***

## 3) Environment variables

### `infra/.env` (proxy & shared secrets)

> **Use strong random values**. You can generate with: `openssl rand -base64 32`

```ini
# === Global ===
PROJECT_NAME=people-events

# === Strapi secrets ===
APP_KEYS=key1,key2,key3,key4
API_TOKEN_SALT=tokenSalt_example
ADMIN_JWT_SECRET=adminJwtSecret_example
JWT_SECRET=userJwtSecret_example

# === Postgres ===
POSTGRES_DB=strapi
POSTGRES_USER=strapi
POSTGRES_PASSWORD=super_secret_db_pwd

# === CORS (comma-separated origins) ===
FRONTEND_URL=https://example.ch
BACKEND_URL=https://api.example.ch

# === Timezone & locale (optional) ===
TZ=Europe/Zurich
```

### `backend/.env` (Strapi runtime)

```ini
# Strapi server
NODE_ENV=production
PUBLIC_URL=${BACKEND_URL}        # e.g., https://api.example.ch

# Database
DATABASE_CLIENT=postgres
DATABASE_HOST=db
DATABASE_PORT=5432
DATABASE_NAME=${POSTGRES_DB}
DATABASE_USERNAME=${POSTGRES_USER}
DATABASE_PASSWORD=${POSTGRES_PASSWORD}
DATABASE_SSL=false

# Security keys (duplicated here for container build/runtime)
APP_KEYS=${APP_KEYS}
API_TOKEN_SALT=${API_TOKEN_SALT}
ADMIN_JWT_SECRET=${ADMIN_JWT_SECRET}
JWT_SECRET=${JWT_SECRET}

# CORS allowed origin(s)
FRONTEND_URL=${FRONTEND_URL}
```

### `frontend/.env` (Next.js)

```ini
NODE_ENV=production
NEXT_PUBLIC_BACKEND_URL=${BACKEND_URL}   # https://api.example.ch
```

> In dev youâ€™d set `http://localhost:1337`, but here we deploy straight to prod.

***

## 4) Caddy config (automatic HTTPS + proxy)

`infra/Caddyfile`:

```caddyfile
# Frontend (Next.js) at example.ch
example.ch {
  encode gzip zstd
  tls youremail@example.com

  @static path /_next/* /favicon.ico /robots.txt /sitemap.xml
  handle @static {
    reverse_proxy frontend:3000
  }

  # Everything else goes to the Next.js server
  reverse_proxy frontend:3000

  header {
    Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
    X-Frame-Options "SAMEORIGIN"
    Referrer-Policy "strict-origin-when-cross-origin"
    X-Content-Type-Options "nosniff"
  }
}

# Backend (Strapi) at api.example.ch
api.example.ch {
  encode gzip zstd
  tls youremail@example.com

  reverse_proxy strapi:1337

  header {
    Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
    X-Frame-Options "SAMEORIGIN"
    Referrer-Policy "strict-origin-when-cross-origin"
    X-Content-Type-Options "nosniff"
  }
}
```

> Caddy will request and renew Letâ€™s Encrypt certs automatically.

***

## 5) Docker Compose (all services)

`infra/docker-compose.yml`:

```yaml
version: "3.9"

name: ${PROJECT_NAME}

services:
  db:
    image: postgres:16-alpine
    restart: unless-stopped
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      TZ: ${TZ}
    volumes:
      - ./data/postgres:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 10

  strapi:
    build:
      context: ../backend
      dockerfile: Dockerfile
    restart: unless-stopped
    depends_on:
      db:
        condition: service_healthy
    environment:
      NODE_ENV: production
      TZ: ${TZ}
      PUBLIC_URL: ${BACKEND_URL}
      DATABASE_CLIENT: postgres
      DATABASE_HOST: db
      DATABASE_PORT: 5432
      DATABASE_NAME: ${POSTGRES_DB}
      DATABASE_USERNAME: ${POSTGRES_USER}
      DATABASE_PASSWORD: ${POSTGRES_PASSWORD}
      DATABASE_SSL: "false"
      APP_KEYS: ${APP_KEYS}
      API_TOKEN_SALT: ${API_TOKEN_SALT}
      ADMIN_JWT_SECRET: ${ADMIN_JWT_SECRET}
      JWT_SECRET: ${JWT_SECRET}
      # Allow public GET from the frontend origin; adjust in Strapi settings too.
    volumes:
      - ../backend/public/uploads:/app/public/uploads
    healthcheck:
      test: ["CMD", "node", "-e", "fetch('http://localhost:1337/_health').then(()=>process.exit(0)).catch(()=>process.exit(1))"]
      interval: 15s
      timeout: 5s
      retries: 20

  frontend:
    build:
      context: ../frontend
      dockerfile: Dockerfile
    restart: unless-stopped
    environment:
      NODE_ENV: production
      NEXT_PUBLIC_BACKEND_URL: ${BACKEND_URL}
      TZ: ${TZ}
    depends_on:
      strapi:
        condition: service_started
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://localhost:3000 || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 20

  caddy:
    image: caddy:2
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    environment:
      TZ: ${TZ}
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile:ro
      - ./data/caddy:/data
      - ./data/caddy_config:/config
    depends_on:
      - frontend
      - strapi

networks:
  default:
    name: ${PROJECT_NAME}_net
```

> Volumes:
>
> *   Postgres data: `infra/data/postgres`
> *   Caddy certs/config: `infra/data/caddy*`
> *   Strapi uploads: `backend/public/uploads` (bind-mounted for easy backup)

***

## 6) Dockerfiles

### `backend/Dockerfile` (Strapi)

```dockerfile
# Build image
FROM node:20-alpine AS build
WORKDIR /app

# Strapi needs python & build tools for some packages
RUN apk add --no-cache python3 make g++ libc6-compat

COPY package.json yarn.lock ./
RUN yarn install --frozen-lockfile

COPY . .
# Build Strapi admin & compile
RUN yarn build

# Production image
FROM node:20-alpine
WORKDIR /app
ENV NODE_ENV=production

# Runtime deps for sharp and others
RUN apk add --no-cache libc6-compat

COPY package.json yarn.lock ./
RUN yarn install --frozen-lockfile --production

# Copy app (including built admin)
COPY --from=build /app ./

EXPOSE 1337
CMD ["yarn", "start"]
```

### `frontend/Dockerfile` (Next.js)

This serves Next with the Node server (good for SSR). If youâ€™re mostly static, you can switch to `next start` with output:standalone to shrink image size.

```dockerfile
# Build
FROM node:20-alpine AS deps
WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install --frozen-lockfile

FROM node:20-alpine AS build
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
ENV NEXT_TELEMETRY_DISABLED=1
RUN yarn build

# Production runtime (standalone)
FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1

# Use Next.js standalone output for minimal runtime
COPY --from=build /app/.next/standalone ./
COPY --from=build /app/public ./public
# Copy Next.js required files
COPY --from=build /app/.next/static ./.next/static

EXPOSE 3000
CMD ["node", "server.js"]
```

> Ensure your `next.config.js` includes `output: 'standalone'`:

```js
// frontend/next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'standalone',
  images: {
    // If you render Strapi images via Next <Image/>
    remotePatterns: [
      { protocol: 'https', hostname: 'api.example.ch' }
    ],
  },
};
module.exports = nextConfig;
```

***

## 7) Strapi configuration files

Create `backend/config/database.ts`:

```ts
export default ({ env }) => ({
  connection: {
    client: 'postgres',
    connection: {
      host: env('DATABASE_HOST', 'localhost'),
      port: env.int('DATABASE_PORT', 5432),
      database: env('DATABASE_NAME', 'strapi'),
      user: env('DATABASE_USERNAME', 'strapi'),
      password: env('DATABASE_PASSWORD', ''),
      ssl: env.bool('DATABASE_SSL', false),
    },
    acquireConnectionTimeout: 60000,
  },
});
```

Create `backend/config/server.ts`:

```ts
export default ({ env }) => ({
  host: '0.0.0.0',
  port: env.int('PORT', 1337),
  url: env('PUBLIC_URL', ''),
  app: { keys: env.array('APP_KEYS') },
});
```

Create `backend/config/plugins.ts`:

```ts
export default ({ env }) => ({
  // local uploads by default; no S3 provider configured
  // If you add S3 later, configure upload plugin here.
});
```

Optional CORS hardening: `backend/config/middlewares.ts`

```ts
export default [
  'strapi::errors',
  {
    name: 'strapi::security',
    config: {
      contentSecurityPolicy: {
        useDefaults: true,
        directives: {
          'img-src': ["'self'", "data:", "blob:", "*.example.ch"],
          'media-src': ["'self'", "data:", "blob:", "*.example.ch"],
          'connect-src': ["'self'", "https://api.example.ch"],
        },
      },
    },
  },
  {
    name: 'strapi::cors',
    config: {
      origin: [process.env.FRONTEND_URL || 'https://example.ch'],
      headers: ['Content-Type', 'Authorization', 'Origin', 'Accept'],
      methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
      credentials: true,
    },
  },
  'strapi::poweredBy',
  'strapi::logger',
  'strapi::query',
  'strapi::body',
  'strapi::session',
  'strapi::favicon',
  'strapi::public',
];
```

***

## 8) Bootstrap the apps (first time)

If you havenâ€™t created the Strapi/Next.js apps yet:

```bash
# From your laptop (or VPS), in the repo root:
cd backend
npx create-strapi-app@latest . --no-run --quickstart
# It will scaffold; you already have config & Dockerfile that will override defaults.

cd ../frontend
npx create-next-app@latest . --ts --eslint --src-dir --app --tailwind --import-alias "@/*"
```

Commit everything to git (optional but recommended).

***

## 9) First deployment

```bash
# On the VPS
cd ~/people-events/infra

# Build and start
docker compose build
docker compose up -d

# Tail logs
docker compose logs -f
```

Once containers are healthy:

*   Visit **<https://api.example.ch/admin>** to create the **Strapi admin** user.
*   Visit **<https://example.ch>** for the frontend.

> If Caddy canâ€™t obtain certs immediately, check DNS propagation and ports 80/443 reachability, then `docker compose restart caddy`.

***

## 10) Strapi permissions & content

*   In **Settings â†’ Roles â†’ Public**, enable `find`/`findOne` on your public collection types you want to expose (e.g., Person, Event).
*   Create **content types** (Person, Event, Link, Photo) in the Strapi admin or via the Content Type Builder.
*   Upload a few photos â€” theyâ€™ll be stored locally under `backend/public/uploads`.

***

## 11) Backup strategy (DB + uploads)

Create `infra/backup/backup.sh`:

```bash
#!/usr/bin/env bash
set -euo pipefail

# Config
PROJECT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
BACKUP_DIR="${PROJECT_DIR}/backup/archives"
DATE="$(date +%Y-%m-%d_%H-%M)"
mkdir -p "$BACKUP_DIR"

# Database dump
echo "[*] Dumping Postgres..."
docker compose exec -T db pg_dump -U "${POSTGRES_USER}" "${POSTGRES_DB}" > "${BACKUP_DIR}/db_${DATE}.sql"

# Media & configs
echo "[*] Archiving uploads and configs..."
tar czf "${BACKUP_DIR}/uploads_${DATE}.tar.gz" -C "${PROJECT_DIR}/../backend/public" uploads
tar czf "${BACKUP_DIR}/caddy_${DATE}.tar.gz" -C "${PROJECT_DIR}" data/caddy data/caddy_config Caddyfile .env

echo "[âœ“] Backups written to ${BACKUP_DIR}"
```

Make it executable:

```bash
cd infra/backup
chmod +x backup.sh
```

Optional: add a cron job to run nightly:

```bash
(crontab -l; echo "17 2 * * * cd $HOME/people-events/infra && ./backup/backup.sh >> ./backup/cron.log 2>&1") | crontab -
```

Store archives offâ€‘server periodically (e.g., download or `rclone` to a cloud drive).  
**Restore notes**: keep basic commands in `restore-notes.md` (dump `psql < file.sql`, untar uploads).

***

## 12) Updates & zeroâ€‘downtime deploy

When you edit code:

```bash
# Pull latest repo changes (if using git)
git pull

# Rebuild only changed services
cd infra
docker compose build frontend strapi
docker compose up -d
```

**Data is persistent** in the volumes/bind mounts.  
To update OS/Docker: `sudo apt-get update && sudo apt-get upgrade -y`

***

## 13) Hardening & housekeeping

*   **SSH**: disable password auth; use keys.
*   **UFW**: only 22,80,443 open (already done).
*   **Swap**: enable a small swapfile if RAM is tight.
*   **Fail2ban** (optional): protects SSH.
*   **Strapi admin**: use strong password; set up **email** (SMTP) for password resets if needed.
*   **Rate limiting**: you can add Caddy rateâ€‘limit or use a small middleware in front if required.

***

## 14) Optional: Move media to S3 later

If growth demands it, switch Strapi to S3â€‘compatible storage (Backblaze B2 / Wasabi / MinIO):

1.  `yarn add @strapi/provider-upload-aws-s3` in `backend/`
2.  Configure credentials in `backend/config/plugins.ts`
3.  Add env vars (S3\_ACCESS\_KEY\_ID, S3\_SECRET\_ACCESS\_KEY, S3\_ENDPOINT, S3\_REGION, S3\_BUCKET, etc.)
4.  Rebuild `strapi` service.

Until then, **local uploads** are simplest and costâ€‘free.

***

## 15) Troubleshooting quick list

*   **Certificates not issuing**: DNS not pointing to VPS or port 80 blocked.
*   **Frontend blank**: check `NEXT_PUBLIC_BACKEND_URL` and API permissions.
*   **CORS errors**: ensure `FRONTEND_URL` matches your domain and CORS middleware allows it.
*   **Strapi admin not loading**: confirm `PUBLIC_URL` and that `yarn build` ran in Strapi image (it does in Dockerfile).
*   **Images not showing**: verify Strapi returns absolute URLs and Next `<Image/>` remotePatterns includes `api.example.ch`.

***

### Thatâ€™s it ðŸŽ¯

This setup will run comfortably on a **lowâ€‘cost Hetzner VPS**, keep your ops minimal, and let you iterate on content and UI quickly. If you want, I can:

*   generate a **zip repo** with these files filled for your chosen domain,
*   add **seed data scripts** for your Person/Event models,
*   or help you **migrate** an existing local project to this stack.

Do you want me to customize the files above to your actual domain name and pick a specific Hetzner plan (CPX/CX)?

